<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>tts-bridge demo</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: system-ui, -apple-system, sans-serif; background: #0f1117; color: #e1e4e8; min-height: 100vh; display: flex; flex-direction: column; align-items: center; padding: 2rem 1rem; }
  h1 { font-size: 1.4rem; font-weight: 600; margin-bottom: 0.25rem; }
  .subtitle { color: #8b949e; font-size: 0.85rem; margin-bottom: 1.5rem; }
  .card { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 1.25rem; width: 100%; max-width: 520px; margin-bottom: 1rem; }
  label { display: block; font-size: 0.8rem; color: #8b949e; margin-bottom: 0.3rem; }
  input, textarea, select { width: 100%; background: #0d1117; border: 1px solid #30363d; border-radius: 6px; color: #e1e4e8; padding: 0.5rem 0.65rem; font-size: 0.9rem; font-family: inherit; outline: none; }
  input:focus, textarea:focus { border-color: #58a6ff; }
  textarea { resize: vertical; min-height: 3.5rem; }
  .row { display: flex; gap: 0.75rem; margin-bottom: 0.75rem; }
  .row > div { flex: 1; }
  .actions { display: flex; gap: 0.5rem; margin-top: 0.75rem; }
  button { flex: 1; padding: 0.55rem 1rem; border: none; border-radius: 6px; font-size: 0.85rem; font-weight: 500; cursor: pointer; transition: opacity 0.15s; }
  button:disabled { opacity: 0.4; cursor: not-allowed; }
  button:not(:disabled):hover { opacity: 0.85; }
  .btn-speak { background: #238636; color: #fff; }
  .btn-cancel { background: #da3633; color: #fff; }
  .btn-reset { background: #30363d; color: #e1e4e8; }
  #status { font-size: 0.8rem; padding: 0.5rem 0; }
  .dot { display: inline-block; width: 7px; height: 7px; border-radius: 50%; margin-right: 0.4rem; vertical-align: middle; }
  .dot-off { background: #484f58; }
  .dot-on { background: #3fb950; }
  .dot-streaming { background: #d29922; }
  .dot-error { background: #f85149; }
  #log { background: #0d1117; border: 1px solid #30363d; border-radius: 6px; padding: 0.65rem; font-family: ui-monospace, monospace; font-size: 0.75rem; line-height: 1.5; max-height: 180px; overflow-y: auto; color: #8b949e; white-space: pre-wrap; word-break: break-all; }
  .log-in { color: #58a6ff; }
  .log-out { color: #3fb950; }
  .log-err { color: #f85149; }
  .log-audio { color: #d29922; }
  .metrics { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; }
  .metric { background: #0d1117; border: 1px solid #30363d; border-radius: 6px; padding: 0.6rem 0.75rem; }
  .metric-label { font-size: 0.7rem; color: #8b949e; text-transform: uppercase; letter-spacing: 0.03em; margin-bottom: 0.15rem; }
  .metric-value { font-family: ui-monospace, monospace; font-size: 1.1rem; font-weight: 600; color: #e1e4e8; }
  .metric-value.active { color: #d29922; }
  .metric-unit { font-size: 0.7rem; font-weight: 400; color: #8b949e; margin-left: 0.15rem; }
</style>
</head>
<body>

<h1>tts-bridge demo</h1>
<p class="subtitle">WebSocket streaming TTS &mdash; type text, hear audio</p>

<div class="card">
  <div class="row">
    <div style="flex:2">
      <label for="url">WebSocket URL</label>
      <input id="url" type="text" value="ws://localhost:8080/v1/audio/stream">
    </div>
    <div>
      <label for="voice">Voice</label>
      <input id="voice" type="text" value="af_heart">
    </div>
  </div>
  <div>
    <label for="text">Text</label>
    <textarea id="text" placeholder="Type something to synthesize...">Hello! This is a demo of the TTS bridge. You can type any text here and hear it spoken in real time.</textarea>
  </div>
  <div class="actions">
    <button class="btn-speak" id="btn-speak">Speak</button>
    <button class="btn-cancel" id="btn-cancel" disabled>Cancel</button>
    <button class="btn-reset" id="btn-reset" disabled>Reset</button>
  </div>
  <div id="status"><span class="dot dot-off"></span>Disconnected</div>
</div>

<div class="card">
  <label style="margin-bottom:0.5rem">Metrics</label>
  <div class="metrics">
    <div class="metric">
      <div class="metric-label">Time to start</div>
      <div class="metric-value" id="m-ttfb">&mdash;</div>
    </div>
    <div class="metric">
      <div class="metric-label">First audio</div>
      <div class="metric-value" id="m-first-audio">&mdash;</div>
    </div>
    <div class="metric">
      <div class="metric-label">Total time</div>
      <div class="metric-value" id="m-total">&mdash;</div>
    </div>
    <div class="metric">
      <div class="metric-label">Audio duration</div>
      <div class="metric-value" id="m-audio-dur">&mdash;</div>
    </div>
    <div class="metric">
      <div class="metric-label">Chunks</div>
      <div class="metric-value" id="m-chunks">&mdash;</div>
    </div>
    <div class="metric">
      <div class="metric-label">Total bytes</div>
      <div class="metric-value" id="m-bytes">&mdash;</div>
    </div>
    <div class="metric">
      <div class="metric-label">Avg chunk interval</div>
      <div class="metric-value" id="m-chunk-interval">&mdash;</div>
    </div>
    <div class="metric">
      <div class="metric-label">Playback buffer</div>
      <div class="metric-value" id="m-buffer">&mdash;</div>
    </div>
  </div>
</div>

<div class="card">
  <label>Log</label>
  <div id="log"></div>
</div>

<script>
(function () {
  const $ = (s) => document.querySelector(s);
  const urlInput    = $('#url');
  const voiceInput  = $('#voice');
  const textInput   = $('#text');
  const btnSpeak    = $('#btn-speak');
  const btnCancel   = $('#btn-cancel');
  const btnReset    = $('#btn-reset');
  const statusEl    = $('#status');
  const logEl       = $('#log');

  let ws = null;
  let audioCtx = null;
  let nextPlayTime = 0;
  let sampleRate = 24000;
  let streaming = false;

  // ---- Metrics state ----
  let sendTime = 0;        // performance.now() when text was sent
  let startTime = 0;       // when "start" frame arrived
  let firstAudioTime = 0;  // when first binary chunk arrived
  let lastChunkTime = 0;
  let chunkCount = 0;
  let totalBytes = 0;
  let chunkIntervalSum = 0;
  let bufferTimer = null;

  function resetMetrics() {
    sendTime = 0; startTime = 0; firstAudioTime = 0; lastChunkTime = 0;
    chunkCount = 0; totalBytes = 0; chunkIntervalSum = 0;
    for (const id of ['#m-ttfb','#m-first-audio','#m-total','#m-audio-dur','#m-chunks','#m-bytes','#m-chunk-interval','#m-buffer']) {
      $(id).innerHTML = '&mdash;';
      $(id).classList.remove('active');
    }
    if (bufferTimer) { clearInterval(bufferTimer); bufferTimer = null; }
  }

  function setMetric(id, value, unit, active) {
    const el = $(id);
    el.innerHTML = value + (unit ? `<span class="metric-unit">${unit}</span>` : '');
    if (active) el.classList.add('active'); else el.classList.remove('active');
  }

  function startBufferMonitor() {
    if (bufferTimer) clearInterval(bufferTimer);
    bufferTimer = setInterval(() => {
      if (!audioCtx || !streaming) { setMetric('#m-buffer', '0', 'ms'); return; }
      const buffered = Math.max(0, (nextPlayTime - audioCtx.currentTime) * 1000);
      setMetric('#m-buffer', Math.round(buffered), 'ms', true);
    }, 100);
  }

  // ---- Logging ----
  function log(msg, cls) {
    const span = document.createElement('span');
    span.className = cls || '';
    span.textContent = msg + '\n';
    logEl.appendChild(span);
    logEl.scrollTop = logEl.scrollHeight;
  }

  // ---- Status indicator ----
  function setStatus(text, dotClass) {
    statusEl.innerHTML = `<span class="dot ${dotClass}"></span>${text}`;
  }

  // ---- Audio ----
  function ensureAudioCtx(rate) {
    if (audioCtx && audioCtx.sampleRate === rate) return;
    if (audioCtx) audioCtx.close();
    audioCtx = new AudioContext({ sampleRate: rate });
    nextPlayTime = 0;
  }

  function playPCM16(arrayBuffer) {
    if (!audioCtx) return;
    const int16 = new Int16Array(arrayBuffer);
    const float32 = new Float32Array(int16.length);
    for (let i = 0; i < int16.length; i++) {
      float32[i] = int16[i] / 32768;
    }
    const buf = audioCtx.createBuffer(1, float32.length, audioCtx.sampleRate);
    buf.getChannelData(0).set(float32);
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    src.connect(audioCtx.destination);
    if (nextPlayTime < audioCtx.currentTime) {
      nextPlayTime = audioCtx.currentTime;
    }
    src.start(nextPlayTime);
    nextPlayTime += buf.duration;
  }

  function stopAudio() {
    if (audioCtx) {
      audioCtx.close();
      audioCtx = null;
    }
    nextPlayTime = 0;
  }

  // ---- WebSocket ----
  function connect() {
    if (ws && ws.readyState <= 1) return;
    const url = urlInput.value.trim();
    if (!url) return;

    ws = new WebSocket(url);
    ws.binaryType = 'arraybuffer';
    setStatus('Connecting...', 'dot-off');
    log('Connecting to ' + url, 'log-out');

    ws.onopen = () => {
      setStatus('Connected', 'dot-on');
      log('Connected', 'log-out');
      btnSpeak.disabled = false;
      btnReset.disabled = false;
    };

    ws.onclose = (e) => {
      setStatus('Disconnected (' + e.code + ')', 'dot-off');
      log('Disconnected: ' + e.code + (e.reason ? ' ' + e.reason : ''), 'log-err');
      streaming = false;
      btnSpeak.disabled = false;
      btnCancel.disabled = true;
      ws = null;
    };

    ws.onerror = () => {
      setStatus('Connection error', 'dot-error');
      log('WebSocket error', 'log-err');
    };

    ws.onmessage = (e) => {
      if (e.data instanceof ArrayBuffer) {
        const now = performance.now();

        // Metrics: first audio chunk
        if (chunkCount === 0) {
          firstAudioTime = now;
          setMetric('#m-first-audio', Math.round(now - sendTime), 'ms');
        }

        // Metrics: chunk tracking
        if (chunkCount > 0) {
          chunkIntervalSum += now - lastChunkTime;
          setMetric('#m-chunk-interval', Math.round(chunkIntervalSum / chunkCount), 'ms');
        }
        lastChunkTime = now;
        chunkCount++;
        totalBytes += e.data.byteLength;
        setMetric('#m-chunks', chunkCount, '', true);
        setMetric('#m-bytes', totalBytes >= 1024 ? (totalBytes / 1024).toFixed(1) + ' KB' : totalBytes + ' B', '', true);

        // Audio duration from total PCM bytes: bytes / 2 (16-bit) / sampleRate
        const audioDur = totalBytes / 2 / sampleRate;
        setMetric('#m-audio-dur', audioDur.toFixed(2), 's', true);

        playPCM16(e.data);
        return;
      }

      // Text frame — JSON protocol message
      let msg;
      try { msg = JSON.parse(e.data); } catch { log('Bad JSON: ' + e.data, 'log-err'); return; }

      switch (msg.type) {
        case 'start': {
          const now = performance.now();
          sampleRate = msg.sample_rate || 24000;
          ensureAudioCtx(sampleRate);
          streaming = true;
          startTime = now;
          btnCancel.disabled = false;
          btnSpeak.disabled = true;
          setStatus('Streaming: ' + msg.utterance_id, 'dot-streaming');
          setMetric('#m-ttfb', Math.round(now - sendTime), 'ms');
          startBufferMonitor();
          log('\u25B6 start  id=' + msg.utterance_id + '  rate=' + sampleRate, 'log-in');
          break;
        }
        case 'done': {
          const now = performance.now();
          streaming = false;
          btnCancel.disabled = true;
          btnSpeak.disabled = false;
          setStatus('Connected', 'dot-on');
          setMetric('#m-total', Math.round(now - sendTime), 'ms');
          // Finalize metrics — remove active highlights
          for (const id of ['#m-chunks','#m-bytes','#m-audio-dur']) $(id).classList.remove('active');
          log('\u2713 done   id=' + msg.utterance_id, 'log-in');
          break;
        }
        case 'cancelled':
          streaming = false;
          stopAudio();
          btnCancel.disabled = true;
          btnSpeak.disabled = false;
          setStatus('Connected', 'dot-on');
          if (bufferTimer) { clearInterval(bufferTimer); bufferTimer = null; }
          setMetric('#m-buffer', '0', 'ms');
          log('\u2717 cancelled  id=' + msg.utterance_id, 'log-in');
          break;
        case 'error':
          streaming = false;
          btnCancel.disabled = true;
          btnSpeak.disabled = false;
          setStatus('Connected', 'dot-on');
          log('ERROR: ' + msg.message + (msg.utterance_id ? '  id=' + msg.utterance_id : ''), 'log-err');
          break;
        default:
          log('Unknown: ' + JSON.stringify(msg), 'log-err');
      }
    };
  }

  // ---- Actions ----
  btnSpeak.addEventListener('click', () => {
    const text = textInput.value.trim();
    if (!text) return;
    connect();
    // Wait for connection if needed
    function send() {
      if (!ws) return;
      if (ws.readyState === 0) { setTimeout(send, 50); return; }
      if (ws.readyState !== 1) return;
      resetMetrics();
      sendTime = performance.now();
      const payload = { text };
      const voice = voiceInput.value.trim();
      if (voice) payload.voice = voice;
      ws.send(JSON.stringify(payload));
      log('\u2191 send: ' + JSON.stringify(payload), 'log-out');
    }
    send();
  });

  btnCancel.addEventListener('click', () => {
    if (ws && ws.readyState === 1) {
      ws.send(JSON.stringify({ type: 'cancel' }));
      log('\u2191 cancel', 'log-out');
    }
  });

  btnReset.addEventListener('click', () => {
    if (ws && ws.readyState === 1) {
      ws.send(JSON.stringify({ type: 'reset' }));
      log('\u2191 reset', 'log-out');
      stopAudio();
    }
  });

  // Allow Ctrl/Cmd+Enter to speak
  textInput.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
      e.preventDefault();
      btnSpeak.click();
    }
  });
})();
</script>
</body>
</html>
